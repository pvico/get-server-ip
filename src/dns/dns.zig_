const std = @import("std");
const logger = @import("../utilities/logger.zig");
const print = @import("../utilities/print.zig");

pub fn getIp(allocator: std.mem.Allocator, domain: []const u8) ![]u8 {

    const ip: []u8 = try allocator.alloc(u8, 16);
    // ip is returned, it cannot be freed normally in this scope
    errdefer allocator.free(ip);
    @memset(ip, 0);

    const addr_list = try std.net.getAddressList(allocator, domain, 80);
    defer addr_list.deinit();

    if (addr_list.addrs.len == 0) {
        return error.NoAddressFound;
    }

    const ipv4_address =  addr_list.addrs[0].in;
    const bytes: *const [4]u8 = @ptrCast(&ipv4_address.sa.addr);
    _ = try std.fmt.bufPrint(ip, "{d}.{d}.{d}.{d}", .{bytes[0], bytes[1], bytes[2], bytes[3]});

    return ip;
}


pub fn getIpV6(allocator: std.mem.Allocator, domain: []const u8) ![]u8 {

    const ip: []u8 = try allocator.alloc(u8, 40);
    // ip is returned, it cannot be freed normally in this scope
    errdefer allocator.free(ip);
    @memset(ip, 0);

    const addr_list = try std.net.getAddressList(allocator, domain, 80);
    defer addr_list.deinit();

    if (addr_list.addrs.len == 0) {
        return error.NoAddressFound;
    }

    const ipv6_address =  addr_list.addrs[0].in6.sa.addr;
    logger.debug("ipv6_address: {any}", .{ipv6_address});
    // const bytes: *const [16]u8 = @ptrCast(&ipv6_address);
    // _ = try std.fmt.bufPrint(ip, "{x}:{x}:{x}:{x}:{x}:{x}:{x}:{x}",
    //     .{
    //         (bytes[0] << 8) | bytes[1],
    //         (bytes[2] << 8) | bytes[3],
    //         (bytes[4] << 8) | bytes[5],
    //         (bytes[6] << 8) | bytes[7],
    //         (bytes[8] << 8) | bytes[9],
    //         (bytes[10] << 8) | bytes[11],
    //         (bytes[12] << 8) | bytes[13],
    //         (bytes[14] << 8) | bytes[15],
    //     });

    return ip;
}